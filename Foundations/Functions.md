### 函数
函数是R中基础结构单元:为了掌握本书中许多更加高级的技术，你需要对函数是如何工作有很好的基础。你可能已经创建了很多R的函数，并且熟悉它们是如何工作的基础。本章节的目的就是将你对函数已经存在的，不正式的理解转变成对函数是什么以及它们是如何工作的严格的理解。在本章节，你将看到一些有趣的技巧和技术，但是你想要学习的将会更加重要，因为它们是更加高级技术的基础。

理解R最重要的事情就是R中的函数本身就是一个对象。你可以同操作任何其他类型的对象一样去操作函数。这个主题将在functional programming函数式编程中详细的介绍。

##### 纲要
- 函数组成 描述一个函数三个主要的组成部分
- 词法域 教你R中如何通过名字找到值，词法域的过程
- 每个操作是一个函数调用 说明R中发生的每一件事都是一个函数调用的结果，即使看起来不像
- 函数参数 讨论了三种方式给函数提供参数，如何给一个参数列表取调用函数，以及延迟计算的影响
- 特殊的调用 描述了函数的两种特殊类型:中缀和替换函数
- 返回值 讨论了函数如何以及何时返回值，以及在函数退出时一个函数是如何运行的

##### 预备知识
仅仅需要pryr包，用来探索当修改向量的时候将发生什么。

#### 函数组成部分
所有R函数有三个部分:
- 函数体body()， 函数内部的代码
- 函数形参formals()， 参数列表，控制你将如何调用函数
- 环境environment()， 函数变量位置

当你在R中打印函数的时候，会显示这三个重要的成分。如果环境没有显示，意味着函数是在全局环境中创建的。

```
f <- function(x) x^2
f
#> function(x) x^2

formals(f)
#> $x
body(f)
#> x^2
environment(f)
#> <environment: R_GlobalEnv>
```
body(), formals(), and environment()的赋值形式也可以用来修改函数。

像R中所有的对象一样，函数也可以持有任意数目的额外的属性。在base R中使用的一个属性是"srcref"，source reference的简称，指向创建函数的源代码。不像body()，它包括代码注释和其他格式。你还可以为函数增加属性。举个例子，你可以设置class()和增加一个常用的print()方法。

##### 原语函数
函数有三个组成部分的规则存在一个例外。原语函数，例如sum()，直接用.Primitive() 调用C代码，而且不包含R代码。因此它们的formals(), body(), and environment()都是NULL。

```
sum
#> function (..., na.rm = FALSE)  .Primitive("sum")
formals(sum)
#> NULL
body(sum)
#> NULL
environment(sum)
#> NULL
```
原语函数只会在base包里面发现。因为它们在底层操作，它们是非常高效的（原语替代函数不需要做复制），并且针对参数匹配有不同的规则（比如switch和call）。然而，你会造成和R中所有其他函数的行为不同。因此R core团队一般会避免取创建它们，除非必须要使用它们。

#### 词法作用域
Scoping作用域是R中管理如何查看一个符号所对应值的规则集合。在下面的例子中显示了R从符号x到它的值10的作用域的规则。

```
x <- 10
x
#> [1] 10
```
理解作用域可以让你:
- 通过组合函数构建工具，将会在函数编程中介绍
- 否决通常的求值计算规则，做非标准的求值，将会在 non-standard evaluation介绍

R中有两种类型的作用域:词法作用域，在语言层面自动实现，另一个是动态作用域，在动态交互的时候用于选择函数去保存类型。在这里，我们讨论词法作用域，因为它和函数创建密切相关。动态作用域将会在
scoping issues里面具体描述。

词法作用域查找符号值基于当函数被创建时，它们是如何封装的，而不是它们被调用时是如何封装的。通过词法域，你不需要知道函数是如何被调用的，从而找出变量值是哪里被查找的。你仅仅需要查找函数的定义。

在词法作用域中的lexical不是对应于通常的英语定义(“of or relating to words or the vocabulary of a language as distinguished from its grammar and construction”)，来自于计算机
科学中的词法分析，是将代码翻译成编程语言可以理解的文本部分的处理过程的一部分。

R中实现词法作用域主要有四种原则:
- 名字屏蔽
- 函数和变量
- 新的开始
- 动态查找

你可能已经知道许多这些原则，但是你可能还没有明确地想清楚。在查看答案之前，通过思考示例代码检验你的知识。

##### 名字屏蔽
下面的例子揭示了词法作用域中最主要的原则，预测输出结果应该没问题。

```
f <- function() {
  x <- 1
  y <- 2
  c(x, y)
}
f()
rm(f)
```
如果名字没有在函数的内部定义，R将会在上层查找:

```
x <- 2
g <- function() {
  y <- 1
  c(x, y)
}
g()
rm(x, g)
```
如果一个函数定义在另一个函数里面，同样的规则:在当前函数里面查找，然后是函数的定义处，以此类推，直到全局环境，再到其他已经加载的包。先看一下下面的代码，
然后在执行代码确认输出。

```
x <- 1
h <- function() {
  y <- 2
  i <- function() {
    z <- 3
    c(x, y, z)
  }
  i()
}
h()
rm(x, h)
```
规则同样适用于闭包，通过其他函数创建的函数。闭包将会在函数编程里面更加细节的描述。这里我们将仅仅看它们是如何同作用域相联系的。下面的函数，j()返回一个函数。
当我们调用这个函数的时候，你认为这个函数会返回什么呢？

```
j <- function(x) {
  y <- 2
  function() {
    c(x, y)
  }
}
k <- j(1)
k()
rm(j, k)
```
这里看起来有点奇妙。（当这个函数已经被调用了之后，R是如何知道y的值是多少呢）。这是因为k保存了它被定义时候的环境，而且这个环境包含了y的值。环境给你如何深入提供
了一些指示，并且可以找出每个函数保存在环境中的值。

##### 函数和变量
不管相关值的类型，适用同样的原则-寻找函数同寻找变量一模一样:

```
l <- function(x) x + 1
m <- function() {
  l <- function(x) x * 2
  l(10)
}
m()
#> [1] 20
rm(l, m)
```
对于函数，这个规则有一个小小的调整。如果你在明显想要一个函数的上下文中使用一个名字，（例如，f(3)），当搜寻的时候，R将忽视不是函数的对象。在下面的例子中，n会是不同的
值取决于R是在寻找一个函数还是一个变量。

```
n <- function(x) x / 2
o <- function() {
  n <- 10
  n(n)
}
o()
#> [1] 5
rm(n, o)
```
然而，对函数和其他对象使用相同的名字将会让代码产生混淆，最好避免。
##### 新的开始

```{r}
j <- function() {
  if (!exists("a")) {
    a <- 1
  } else {
    a <- a + 1
  }
  print(a)
}
j()
rm(j)
```
你可能会惊讶函数每次返回同样的值1.这是因为每个一个函数被调用，一个新的环境就会被创建。一个函数没法知道它上一次被调用的时候发生了什么。每一次调用都是完全独立的。
（可以在可变状态中寻找一些方式去避免它）

##### 动态查找
词法作用域决定了哪里去寻找值，而不是何时取寻找它们。













