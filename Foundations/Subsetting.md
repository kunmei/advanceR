### 构造子集
R的构造子集操作算子是强大且快速的。掌握构造子集可以让你简洁地表达复杂的操作，这是很少有其他语言可以匹配的。构造子集很难去学习，因为你需要掌握一些相关的概念。
- 三种构造子集操作算子
- 构造子集的六种类型
- 对于不同对象行为的重要区别，例如向量，列表， 因子，矩阵和数据框
- 构造子集结合赋值的使用

本章节帮助你掌握构造子集，从最简单的构造子集的方式开始：通过 [ 去构造一个原子向量，然后逐渐扩展你的知识。首先到更复杂的数据类型，例如数组和列表，然后到其他
构造子集算子，[[ 和 $。之后你就可以学会构造子集和赋值是如何结合去修改对象的一部分，最后你将看到很多有用的应用。

构造子集是str()自然的补充。str()向你展示任意对象的结构，构造子集可以让你从对象中拉出你感兴趣的部分。

##### 小测试
做一个小测试，看看你是否需要去阅读本章节。如果你很快得到答案，你可以舒服地跳过这一章。在答案里面检查你的答案。
1. 通过一个正整数，负整数，一个逻辑向量或者一个字符向量取子集得到什么结果？
2. [, [[, 和 $作用于一个列表会有什么不同？
3. 你什么时候将使用drop = FALSE？
4. 如果x是一个矩阵，x[] <- 0 做的是什么？它与 x <- 0 有什么不同？
5. 使用一个命名的向量如何对分类变量重新打标签？

##### 纲要
- 数据类型 从告诉你使用 [ 开始。你将开始学习六种数据类型，可以用于取原子向量的子集。然后你将学习当取列表，矩阵，数据框和S3对象的时候，这六种数据类型将如何运作。
- 取子集算子 将包括 [[ 和 $，聚焦简化和保存的一些重要原则。
- 取子集和赋值 你将学习赋值的艺术，结合取子集和赋值去修改对象的部分。
- 应用 通过八种重要但不明显的取子集的应用，去解决你在数据分析中经常遇到的问题。

##### 数据类型
学习对原子向量取子集是容易的，然后扩展到高维和更加复杂的对象。我们将从 [ 开始，最常见的取子集算法，然后是 [[ 和 $，另外两种重要的取子集算子。
###### 原子向量
让我们探索一下对一个简单的向量 x 取子集的不同类型。

```
x <- c(2.1, 4.2, 3.3, 5.4)
```
注意在小数点后面的数字给出了向量的原子位置，你可以使用五种方式对一个向量构造子集：
- **正整数** 返回在确定位置的元素：

```
x[c(3, 1)]
#> [1] 3.3 2.1
x[order(x)]
#> [1] 2.1 3.3 4.2 5.4

# 重复索引将产生重复的数值
x[c(1, 1)]
#> [1] 2.1 2.1

# 实数将转成整数
x[c(2.1, 2.9)]
#> [1] 4.2 4.2
```
- **负整数** 将丢弃在确定位置的元素

```
x[-c(3, 1)]
#> [1] 4.2 5.4
```
在一个取子集中，你不可以混和使用正整数和负整数：

```
x[c(-1, 2)]
#> Error in x[c(-1, 2)]: only 0's may be mixed with negative subscripts
```
- **逻辑向量** 选出对应的逻辑值是 TRUE 的元素。这是取子集中可能最有用的类型，因为你可以通过表达式去创建这个逻辑向量：

```
x[c(TRUE, TRUE, FALSE, FALSE)]
#> [1] 2.1 4.2
x[x > 3]
#> [1] 4.2 3.3 5.4
```
如果逻辑向量比被取子集的向量短，它将被循环至同样的长度。

```
x[c(TRUE, FALSE)]
#> [1] 2.1 3.3
# Equivalent to
x[c(TRUE, FALSE, TRUE, FALSE)]
#> [1] 2.1 3.3
```
在索引中缺失的值将在输出中也产生一个缺失值：

```
x[c(TRUE, TRUE, NA, FALSE)]
#> [1] 2.1 4.2  NA
```
- **空值** 将返回原始的向量。对向量来说不常见，但对于矩阵，数据框和数组是有用的。结合赋值使用也是有用的。

```
x[]
#> [1] 2.1 4.2 3.3 5.4
```
- **零值** 返回一个长度为零的向量。这通常不是你有意要做的事情，但是这对于产生测试数据是有用的。

```
x[0]
#> numeric(0)
```
如果向量被命名了，你还可以使用：
- **字符型向量** 返回匹配名字的元素。

```
(y <- setNames(x, letters[1:4]))
#>   a   b   c   d 
#> 2.1 4.2 3.3 5.4
y[c("d", "c", "a")]
#>   d   c   a 
#> 5.4 3.3 2.1

# 像整数索引一样，你可以重复索引
y[c("a", "a", "a")]
#>   a   a   a 
#> 2.1 2.1 2.1

# 用名字取子集，都是精确地匹配
z <- c(abc = 1, def = 2)
z[c("a", "d")]
#> <NA> <NA> 
#>   NA   NA
```
##### 列表
对列表取子集同对原子向量取子集的工作方式一样。使用 [ 将返回一个列表；[[ 和 $,将在下面介绍，返回列表的组成部分。
##### 矩阵和数组
你可以用三种方式对高维类型取子集：
- 多个向量
- 一个单独的向量
- 一个矩阵
对矩阵和数组最常见的取子集是对一维取子集的简单扩展：你可以为每一个维度提供一个一维的索引，用逗号分割。空白取子集现在是有用的，因为可以让你保留所有行或者所有列。

```
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")
a[1:2, ]
#>      A B C
#> [1,] 1 4 7
#> [2,] 2 5 8
a[c(T, F, T), c("B", "A")]
#>      B A
#> [1,] 4 1
#> [2,] 6 3
a[0, -2]
#>      A C
```
默认地，[ 将简化结果到最低可能的维度。在简化和保存中将学会如何避免这个。

因为矩阵和数组是用带有特殊属性的向量形成的，你可以用单个向量对它们进行取子集。在这种情况下，它们将表现得像向量。R中数组是按照列优先进行保存的。

```
(vals <- outer(1:5, 1:5, FUN = "paste", sep = ","))
#>      [,1]  [,2]  [,3]  [,4]  [,5] 
#> [1,] "1,1" "1,2" "1,3" "1,4" "1,5"
#> [2,] "2,1" "2,2" "2,3" "2,4" "2,5"
#> [3,] "3,1" "3,2" "3,3" "3,4" "3,5"
#> [4,] "4,1" "4,2" "4,3" "4,4" "4,5"
#> [5,] "5,1" "5,2" "5,3" "5,4" "5,5"
vals[c(4, 15)]
#> [1] "4,1" "5,3"
```
你还可以用一个整数矩阵对高维的数据类型取子集，如果命名了，用字符型的矩阵。矩阵中的每一行确定一个值的位置，每个列对应被取子集的数组的一个维度。这意味着你可以使用一个两列的矩阵取对一个矩阵取子集，一个三列的矩阵去对一个三维的数组取子集，以此类推。返回结果是一个向量。

```
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
select <- matrix(ncol = 2, byrow = TRUE, c(
  1, 1,
  3, 1,
  2, 4
))
vals[select]
#> [1] "1,1" "3,1" "2,4"
```
##### 数据框
数据框拥有列表和矩阵的双重特性：如果你用一个单一的向量取子集，它们表现得像列表；如果你用两个向量取子集，它们表现得像矩阵。

```
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2, ]
#>   x y z
#> 2 2 2 b
df[c(1, 3), ]
#>   x y z
#> 1 1 3 a
#> 3 3 1 c

# 有两种方式从数据框中选取列
# 列表方式
df[c("x", "z")]
#>   x z
#> 1 1 a
#> 2 2 b
#> 3 3 c
# 矩阵方式
df[, c("x", "z")]
#>   x z
#> 1 1 a
#> 2 2 b
#> 3 3 c

# 当你从数据框选取一列的时候，列表方式和矩阵方式有很大的不同,矩阵
# 方式将简化结果，列表方式则不会
str(df["x"])
#> 'data.frame':    3 obs. of  1 variable:
#>  $ x: int  1 2 3
str(df[, "x"])
#>  int [1:3] 1 2 3
```
##### S3 对象
S3对象是由原子向量，数组以及列表组成的，因此你可以使用上面学到的数据和从str()中得到的知识得到你想到的部分。

##### S4 对象
对于S4对象，还有两个额外的取子集的算子，@ 等同于 $, slot() 等同于 [[ 。@ 比 $ 更加限制，因为如果对象的
槽不存在，将返回一个错误。在面向对象的章节将会有更多的细节描述。

##### 取子集算子
这里介绍另外两种取子集的算子：[[ 和 $. [[ 类似于 [, 除了它只能返回一个值和它可以从列表中取出信息。结合字符的方式
取子集，$ 是一种有用的简写相对于 [[ 。

当操作列表的时候，你需要 [[ 。这是因为当 [ 操作列表的时候，它总是返回一个列表：从不会返回列表的内容。得到它的内容，
你需要使用 [[ 。

因为它总是返回一个单一的值，因此你使用 [[ 时，必须提供的是一个正整数或者是一个字符。

```
a <- list(a = 1, b = 2)
a[[1]]
#> [1] 1
a[["a"]]
#> [1] 1

# If you do supply a vector it indexes recursively
b <- list(a = list(b = list(c = list(d = 1))))
b[[c("a", "b", "c", "d")]]
#> [1] 1
# Same as
b[["a"]][["b"]][["c"]][["d"]]
#> [1] 1
```

因为S3和S4对象可以重载 [ 和 [[ 标准的行为，所以它们对不同类型的对象表现不同。主要的不同通常是你在简化，保存对象和默认是什么之间
如何选择。

##### 简化和保存子集
了解简化和保存子集之间的区别是重要的。简化子集返回的是可能最简单的数据结构，其可以表示输出，并且是交互有用的，因为它通常给你你所
想要的。保存子集保持输出同输入一样的结构，并且通常是易于编程的，因为结果总是同一个类型。
当对矩阵和数据框进行取子集时，省略drop = FALSE是程序错误最常见原因之一。（在你的测试例子里面可能通过，但是当某人传入一个一列的
数据框，它将以一种不可预期和不清楚的方式失败）。

不幸的是，在简化和保存之间如何转换对于不同的数据类型是不同的，具体总结如下表所示。

||简化|保存|
|:-:|:-:|:-:|
|向量|x[[1]]|x[1]|
|列表|x[[1]]|x[1]|
|因子|x[1:4, drop = T]|x[1:4]|
|数组|x[1, ] or x[, 1]|x[1, , drop = F] or x[, 1, drop = F]|
|数据框|x[, 1] or x[[1]]|x[, 1, drop = F] or x[1]|

对于所有的数据类型保存是一样的：输出和输入是同一个类型。简化行为在不同的数据类型中将有所不同，具体描述如下：
- **原子向量**：去除名字。
```
x <- c(a = 1, b = 2)
x[1]
#> a 
#> 1
x[[1]]
#> [1] 1
```
- **列表**：返回列表中的对象，而不是一个单一的列表元素。
```
y <- list(a = 1, b = 2)
str(y[1])
#> List of 1
#>  $ a: num 1
str(y[[1]])
#>  num 1
```
- **因子**：去除没用的因子
```
z <- factor(c("a", "b"))
z[1]
#> [1] a
#> Levels: a b
z[1, drop = TRUE]
#> [1] a
#> Levels: a
```
- **矩阵和数组**：如果任何维度的长度是1，删除那个维度
```
a <- matrix(1:4, nrow = 2)
a[1, , drop = FALSE]
#>      [,1] [,2]
#> [1,]    1    3
a[1, ]
#> [1] 1 3
```
- **数据框**：如果输出是一列，返回一个向量而不是一个数据框
```
df <- data.frame(a = 1:2, b = 1:2)
str(df[1])
#> 'data.frame':    2 obs. of  1 variable:
#>  $ a: int  1 2
str(df[[1]])
#>  int [1:2] 1 2
str(df[, "a", drop = FALSE])
#> 'data.frame':    2 obs. of  1 variable:
#>  $ a: int  1 2
str(df[, "a"])
#>  int [1:2] 1 2
```

##### $
$ 是一个简化的操作符，x$y 等同于 x[["y", exact = FALSE]]。通常被用作取出数据框中一些变量，例如 mtcars$cyl 或者 diamonds$carat。

对于 $ 一个通常错误的用法是，当你吧列名存储在一个变量里面：

```
var <- "cyl"
# Doesn't work - mtcars$var translated to mtcars[["var"]]
mtcars$var
#> NULL

# Instead use [[
mtcars[[var]]
#>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4
```
$ 和 [[ 一个重要的不同在于。$ 支持部分匹配：

```
x <- list(abc = 1)
x$a
#> [1] 1
x[["a"]]
#> NULL
```
如果你想避免这种行为，你可以设置全局选项warnPartialMatchDollar为TRUE。使用这个要小心：它可能会影响你已经加载过的代码中的行为。

##### 越界指标
当索引越界的时候，[ 和 [[ 表示的有所不同。例如，当你尝试一个长度为4的数组的第五个元素，或者用NA和NULL去对一个向量取子集：

```
x <- 1:4
str(x[5])
#>  int NA
str(x[NA_real_])
#>  int NA
str(x[NULL])
#>  int(0)
```




















                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  