### 调试，条件处理和防御性编程
当Ｒ代码执行错误的时候，发生了什么呢?你将要做什么?有什么工具可以处理这些问题呢?本章节将会告诉你如何修复意外问题（调试），向你
展示函数是如何和问题进行沟通的，以及基于这些沟通（条件处理）来采取行动，并且告诉你在它们发生前如何取避免这些问题（防御性编程）。

调试是修复你代码中异常问题的艺术和科学。在本章节，你将学习帮助你找到错误根源的工具和技术。你将学会调试的通用性技术，有用的Ｒ
函数例如traceback() and browser()，以及RStudio中的交互性工具。

不是所有的问题都是无法预期的。当你写一个函数的时候，你通常可以预测潜在的问题（比如一个不存在的文件或者输出的错误类型）。同用户
沟通这些问题是**conditions**的工作:错误，警告和信息。

- 致命的错误由stop()产生，并且强制所有的执行停止。当函数没有任何方式去执行的时候，错误就产生了。
- 警告由warning()产生，去显示潜在的问题，例如当一个向量化的输入的一些元素是无效的，例如log(-1:2)。
- 信息是由message()产生的，以一种可以被用户很好抑制的方式给出信息输出(?suppressMessages())。我通常会使用信息让用户知道
  对于一个重要的缺失值，函数选择了什么值。
  
条件通常会显著地显示出来，以黑色字体或者红颜色的字体取决于Ｒ的界面。你可以将它们区分开，因为错误总是以“Error”开始的，警告总是
以“Warning message”开始的。函数作者还可以用print() or cat()与它们的使用者进行交互，但是我认为这不是一个好主意，因为这很难
捕获或者选择性的忽略这种输出。输出的结果不是一个条件，因此你不能使用你将在下面学到的任何一个有用的条件处理工具。

条件处理工具，例如withCallingHandlers(), tryCatch(), and try()，当一个条件发生的时候，可以允许你采用特殊的行动。举个例子，
如果你拟合很多模型，即使其中一个无法收敛，你可能会想继续拟合其他的。基于Common Lisp的思想，Ｒ提供了一个及其强大的条件处理系统，
但是现在没有很好地文档化和经常被使用。本章节将会告诉你最重要的基础，但是如果你想学习更多，我推荐下面的两个资源:
- A prototype of a condition system for R by Robert Gentleman and Luke Tierney。这描述了一个Ｒ条件系统的早期版本。
　当这个文档出来的时候，实现可能会有些改动，它提供了一种很多的方式，这些细节是如何拼接在一起的，以及它设计时候的一些动机。
- Beyond Exception Handling: Conditions and Restarts by Peter Seibel。描述了Lisp中的异常处理，同Ｒ中的方法非常类似，
　它提供了有用的动机和更加复杂的例子。我已经提供了该章节的Ｒ的翻译http://adv-r.had.co.nz/beyond-exception-handling.html。
 
 本章节包括了对于防御性编程的讨论，在错误发生之前避免发生。短期来看，你可能会花更多的时间写代码，但从长期来看，你将节约时间，因为
 错误信息将会更具有价值，方便你更快的找到错误的根源。防御性编程的基本原则就是“fail fast”，一旦一些是事情出错了就抛出错误。
 在Ｒ中，采取了三种特定的形式:检查输入正确，避免非标准的计算，避免函数可以得到不同类型的输出。
 
#####  纲要
- 调试技巧提供了一种更通用的方法取查找和解决bug。
- 调试工具介绍Ｒ函数，Rstudio特征去帮助你更精确地定位错误发生的位置
- 条件处理展示如何抓住条件（错误，警告和信息）。这将使得在错误存在的情况下，写出更加鲁棒性和更加具有信息的代码。
- 防御性编程告诉你关于防御性编程的一些重要的技巧，将阻止bug第一时间发生。

#### 调试技巧
Finding your bug is a process of confirming the many things that you believe are true — until you find one which is not true.
—Norm Matloff

调试代码是具有挑战性的，很多bug是狡猾的，难以发现的。的确，如果bug是显而易见的，你可能已经在第一时间避免它了。然而，你可以有成果地用print()打法查找
出一个问题，但是多数情况下，其他方法将是受欢迎的。在本部分，我们将讨论一些有用的工具，R and RStudio提供的，描述了调试的一个通用的流程。

尽管下面的过程不是简单明了的，但是当调试的时候，将帮助你组织你的思想。通常有四步:

1. 意识到你有一个bug。

   如果你阅读本章节，你可能已经完成了这一步。这是及其重要的一步:不意识到bug的存在，bug不会被修复。这也是当写高质量代码的时候，单元测试的重要性。
   不幸的是，自动测试不在本书的范围内，你可以阅读它http://r-pkgs.had.co.nz/tests.html.
   
2. 使它可重复的。
   
   一旦你意识到你有一个bug，你需要在命令中可以重现它。没有这个，找到它的错误根源将变得及其困难，以及无法确保你已经修复它了。
   
   通常来说,一开始一整段代码会出错，你需要找到造成出错的最短的代码。二分搜索是有用的。你需要不断的移除一般代码直到你找到错误。
   这是快速的，因为你每次只需要看一半的代码。
   
   如果产生一个bug时间很长，找出如何快速的产生它是值得的。你做的越快，你就可以更快速的找到原因。
   
   当你创建一个小的例子，你会发现同样的输入不会产生bug。注意:当诊断bug的原因的时候，将会是有用的。
   
   如果你在使用一个自动测试，创建一个自动测试的例子是有用的。如果已经存在的测试覆盖度低，可以增加测试确保代码是正常的。这会减少
   产生新bug的可能性。
   
3. 找到它在哪里

   如果你是幸运的，下面部分的其中一个工具将帮助你快速定位代码中的bug。通常，你需要对这个问题想的更多一点。采用语义方法是极好的。
   产生假设，设计实验测试它们，并记录你的结果。这看起来工作量很大，但是系统的方法最终为节约你的时间。我经常花费很多时间依赖我的
   直觉去解决一个bug。当采用一个系统的方法的时候会好很多。
   
4. 修复它并进行测试

   一旦你找到一个错误，你需要找到如何修复它，并检验修复之后是可以工作的。拥有自动测试是有用的。这不仅会确保你的确已经修复了这个
   错误，它还是确保在过程中你没有产生新的bug。没有自动话测试，确保记录正确的结果，并检查之前失败的输入。
   
#### 调试工具
为了实现调试的策略，你需要工具。在本章节，你将学到Ｒ和Rstudio提供的工具。Rstudio的集成调试使得Ｒ已有的工具已一种更友好的方式
展现出来。这里我将同时介绍R and RStudio，这样无论什么环境你都可以工作。你可以看官方的文档，反映了最新版本RStudio的工具。
[RStudio debugging documentation](http://www.rstudio.com/ide/docs/debugging/overview)

有三种调试的工具:
- RStudio的错误查看器，traceback()列出了导致错误调用的序列。
- RStudio’s “Rerun with Debug”　工具和options(error = browser)打开了一个错误发生时的交互式进程
- RStudio’s的断点和browser()打开一个在代码任何位置的交互式进程

下面我将详细介绍这三种工具。

当书写新的函数的时候，你不应该使用这些工具。如果你发现你自己在频繁地使用这些工具在新的代码里，你可能需要重新思考你的方法。
避免一次写一个很大的函数，拆分成小的功能模块。如果你从小的函数开始写起，你会很快发现为什么一些代码不工作。如果你一开始就
写很长的函数，最后你会发现你需要花费很大力气取寻找问题的根源。

##### 确定调用的顺序
第一个工具是call stack，导致错误的调用顺序。举个简单的例子:你可以看到f() calls g() calls h() calls i()，最终将字符串
和数字加在一起，导致了一个错误。

```
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)
```
当我们在Rstudio跑这个代码的时候，我们可以看到如下错误。

在错误信息的右边出现了两个选择:“Show Traceback” and “Rerun with Debug”。如果你按“Show traceback”，你可以看到

如果你不是使用Rstudio,你可以使用 traceback()得到同样的信息:

```
traceback()
# 4: i(c) at exceptions-example.R#3
# 3: h(b) at exceptions-example.R#2
# 2: g(a) at exceptions-example.R#1
# 1: f(10)
```
从调用栈的底部阅读到上面:最初的调用是f()，其调用了g(),然后是h(),再然后是i(),其产生了错误。如果你调用你source()到Ｒ
中的代码，调用栈会显示函数的位置，以filename.r#linenumber的形式。它们在Rstudio中是可以点击的，点击之后，会定位到
相应的行。

有时候这些信息已经足够让你定位到错误，并且修复它。然而，通常不是。traceback()向你展示错误是在哪里发生的，但是不是为什么。
下一个有用的工具是交互式调试器，可以让你暂停函数的执行，并交互式探索它的状态。

##### 浏览错误
进入到交互式调试器最简单的方式是通过RStudio’s “Rerun with Debug”工具。它会重新跑出错的代码，在错误发生的地方暂停执行。
现在你已经在函数内部的交互式状态，你可以操作任何定义在这里的对象。你可以看到编辑器里面的相应的代码，在“Environment”面板
里面看到当前环境的对象。调用栈在Traceback的面板，在控制台你可以跑任意的Ｒ代码。

除了常规的Ｒ函数，在debug模式你可以有一些特殊的操作。你可以通过Rstudio的工具栏或者是键盘来操作它们:
- Next, n:执行函数的下一步，如果你一个名字为n的变量要小心:打印它你需要使用print(n)。
- Step into,or s:同next类似，不过如果下一步是一个函数，它会进入函数内部，然后一行一行的操作。
- Finish, or f:停止当前循环或者函数的执行。
- Continue, c:离开交互式的调试，继续函数正常的执行。如果你已经修复了错误的状态，并且想要检查函数是正确的执行，这是有用的。
- Stop, Q:停止调试，终止函数，返回全局环境。一旦你已经找到问题所在，使用它，然后修复bug，再次加载code。

还有两个不是那么有用的命令，在工具栏中是没有的:
- Enter:重复之前的命令。这很容易偶然的激活它。因此我使用options(browserNLdisabled = TRUE)关闭它。
- where:打印活跃调用的调用栈，等同于traceback。

在RStudio之外要进入这种调试的模式，当错误发生的时候，你可以使用error选项指定一个函数去执行。同 Rstudio’s debug非常类似的
函数是browser():它会在错误产生的界面开始一个交互式的界面。




  　
  　
