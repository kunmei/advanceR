### Functionals
越可靠的代码，一定是越透明的。特别是，嵌套条件和循环必须带有很大的疑问去审视。复杂的操作流会使程序员混淆。
混乱的代码通常隐藏着bug。

一个高阶函数是一个将函数当做输入，并返回函数的函数。我们已经看到了高阶函数的一种类型:闭包，由另外一个函数返回的函数。
相对于闭包之外的是叫做functional，一个将函数作为输入，返回一个向量的函数。这里是一个简单的functional:它调用一个
由1000个随机均匀数作为输入的函数。

```
randomise <- function(f) f(runif(1e3))
randomise(mean)
randomise(sum)
```
很有可能你已经使用了泛函的功能:三个最常使用的就是lapply(), apply(), and tapply()。这三个都是将一个函数作为输入，并
返回一个向量作为输出。

泛函的一个通常使用是作为for循环的替代。For循环在R中有一个坏名声。它们有一个运行慢的坏名声。(尽管这个名声只是部分正确的，
详细看modification in place）。但for循环真正的缺点是它们不是很富有表现力。一个for循环表达的是它们遍历某些事情，但没有
表达出一个更高的目标。相比使用一个for循环，更好地方式是使用一个泛函。每一个泛函都是针对一个特定的任务设定的，因此当你识别
一个泛函的时候，你将立刻知道它为啥被使用。除了替换for循环，泛函还扮演了其他角色。它们对封装操作通用数据任务像split-apply-combine，
对于函数性的思考，和对于和一些数学函数一起使用是有用的。

泛函通过更好地沟通意图减少你代码中的bug。在基础R包中泛函实现是经过很好测试并且是高效的，因为它们被很多人使用。许多是通过c写的，
使用很多特殊的技巧去提升性能。使用泛函不一定总是产生最快的代码，然而，它可以帮助你清楚地交流，并且构建很多问题的工具。一味地关注
速度只是使用泛函的错误认识罢了。一旦你有清晰和正确的代码，你就可以使用在improving the speed of your code中学到的技术去加速
它。

##### 纲要
- 我的第一个泛函:lapply()介绍你的第一个泛函:lapply()。
- For循环泛函，向你展示lapply()的变种，从而产生不同的输出，采用不同的输入，并利用不同的方式分布式计算。
- 数据结构泛函　讨论同更多复杂数据结构一起工作的泛函，例如矩阵和数组
- 泛函编程　告诉你关于强大的Reduce() and Filter()函数，同列表在一起工作是有用的
- 数学泛函　讨论同数学比较相关的泛函，例如根查找，集成和优化
- 不应该转换成函数的循环　提供一些主要的注意事项，关于当你不想将循环转换成泛函的时候
- 函数族　本章向你展示泛函如何可以被当做一个简单的建造积木，并且使用它创建一套强大和一致性的工具

##### 我的第一个泛函:lapply()
最简单的泛函是lapply(),这也许你已经熟悉。lapply()调用一个函数，并将它应用到列表中的每一个元素，并且用列表形式返回结果。
lapply()是许多其他很多泛函的建造基石，因此了解它是如何工作的是重要的。这里是一个形象化的展示:

lapply()为了性能是用c写的，我们可以写一个简单的R实现做同样的事情:

```
lapply2 <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```
从这个代码来看，你可以看到lapply()是一个通用的循环模型的封装。为输出创建一个容器，应用f()到列表的每一个部分，然后用结果
去填充这个容器。所有其他的循环泛函都是这些主题的变种:它们都是使用输入或者输出的不同类型。

lapply()使得对列表的操作更加容易，通过消除很多同循环相联系的引用。这个将允许你集中在你采用的函数上面:

```
# Create some random data
l <- replicate(20, runif(sample(1:10, 1)), simplify = FALSE)

# With a for loop
out <- vector("list", length(l))
for (i in seq_along(l)) {
  out[[i]] <- length(l[[i]])
}
unlist(out)

# With lapply
unlist(lapply(l, length))
```
(我使用unlist()将输出从一个列表转换成一个向量,使其更加的简洁，后面我们将看到其他方式将输出转换成一个向量)

因为数据框仍然是一个列表，当你想针对数据框的每一列做什么事的话，lapply()仍然是有用的。

```
unlist(lapply(mtcars, class))
mtcars[] <- lapply(mtcars, function(x) x / mean(x))
```
x的片段总是提供给f作为第一个参数。如果你想要不同的参数，你可以使用一个匿名的参数。如果你想得到不同的参数，你可以使用一个匿名的函数。下面的例子在计算固定x的均值的时候使用了不同的衰减量。
```
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)
unlist(lapply(trims, function(trim) mean(x, trim = trim)))
```
